<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>load testing on Nicole van der Hoeven</title>
    <link>https://nicolevanderhoeven.github.io/tags/load-testing/</link>
    <description>Recent content in load testing on Nicole van der Hoeven</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Nicole van der Hoeven</copyright>
    <lastBuildDate>Thu, 30 Nov 2023 13:57:52 +0100</lastBuildDate><atom:link href="https://nicolevanderhoeven.github.io/tags/load-testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Repasemos el G-stack (Café con Grafana #005)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20231130-ccg005-repasemos-el-g-stack/</link>
      <pubDate>Thu, 30 Nov 2023 13:57:52 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20231130-ccg005-repasemos-el-g-stack/</guid>
      <description>&lt;p&gt;En este episodio de Café con Grafana tenemos a Raul Marin, Solutions Engineer (Ingeniero de soluciones?) quien viene a darnos una repasada completisima de todo el stack de Grafana. TODO! Pues hay muchos que no conocen todas las herramientas, caracteristicas y posibilidades que Grafana Labs viene a ofrecer.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/irUr96JV-Sg&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Performance Testing With Nicole Van Der Hoeven (Quality Bits Podcast)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20231128-quality-bits-performance-testing-with-nicole-van-der-hoeven/</link>
      <pubDate>Tue, 28 Nov 2023 14:01:35 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20231128-quality-bits-performance-testing-with-nicole-van-der-hoeven/</guid>
      <description>&lt;p&gt;My friend Lina Zubyte invited me to her podcast Quality Bits to talk about performance testing. We talked about what performance testing is, why it is important, how to get started, and how to get better at it. We also talked about the foundation of any type of testing: empathy.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://qualitybits.buzzsprout.com/2037134/13909242-performance-testing-with-nicole-van-der-hoeven&#34;&gt;Check out the episode here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dimensionando el Grafana Suite (Café con Grafana #004)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20231123-ccg004-dimensionando-el-grafana-suite/</link>
      <pubDate>Thu, 23 Nov 2023 13:51:25 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20231123-ccg004-dimensionando-el-grafana-suite/</guid>
      <description>&lt;p&gt;Almudena Vivanco viene a platicarnos de todos los experimentos y pruebas a las que someten a toda la suite de Grafana. Desde Mimir hasta k6 ella pone al limite todos los elementos constantemente. Además nos dará muchos tips de su experiencia para usar Grafana y mucho mas!&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/O9tAkdKMvDg&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Realistic Tests with Testcontainers (Grafana Office Hours #20)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20231117-goh20-realistic-tests-with-testcontainers/</link>
      <pubDate>Fri, 17 Nov 2023 11:40:46 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20231117-goh20-realistic-tests-with-testcontainers/</guid>
      <description>&lt;p&gt;In this episode of Grafana Office Hours, we talk about realistic unit tests utilizing actual instances of databases and other dependencies. We&amp;rsquo;ll be joined by Manuel de la Peña from AtomicJar, and Pablo Chacin from Grafana to learn how we can use the Testcontainers open-source framework to create lightweight, throwaway dependencies for our tests.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/LtlRvmWzCRE&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&#34;related-links&#34;&gt;Related links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://testcontainers.com/&#34;&gt;Testcontainers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://testcontainers.com/modules/k3s/&#34;&gt;k3s Module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://testcontainers.com/modules/k6/&#34;&gt;k6 Module&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Load Testing on Kubernetes with k6 Private Load Zones (Grafana Office Hours #19)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20231110-goh19-load-testing-on-kubernetes-with-k6-private-load-zones/</link>
      <pubDate>Fri, 10 Nov 2023 10:46:48 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20231110-goh19-load-testing-on-kubernetes-with-k6-private-load-zones/</guid>
      <description>&lt;p&gt;This week, we&amp;rsquo;re talking about how you can do load testing on Kubernetes with k6 Private Load Zones, a new feature on Grafana Cloud k6 that leverages the k6 Kubernetes operator to allow you to run distributed load tests against applications behind a firewall. Here to discuss this new feature are Senior Software Engineer Olha Yevtushenko, Product Manager Daniel González Lopes, Developer Advocate Paul Balogh, and Senior Developer Advocate Nicole van der Hoeven.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/RXLavQT58YA&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&#34;related-links&#34;&gt;Related links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/k6&#34;&gt;The Grafana k6 repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/k6-operator&#34;&gt;k6 operator repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/docs/grafana-cloud/k6/author-run/private-load-zone-v2/&#34;&gt;Docs on Private Load Zones in Grafana Cloud k6&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>(ES) Cómo hacer pruebas de carga con Grafana k6 (Café con Grafana #003)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20231108-ccg003-c%C3%B3mo-hacer-pruebas-de-carga-con-grafana-k6/</link>
      <pubDate>Wed, 08 Nov 2023 13:43:50 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20231108-ccg003-c%C3%B3mo-hacer-pruebas-de-carga-con-grafana-k6/</guid>
      <description>&lt;p&gt;Daniel González Lopes nos viene a demostrar cómo hacer pruebas de carga con Grafana k6 desde zero, y cómo utilizar k6 para ejecutar otros tipos de pruebas. En este episodio para principiantes, hablaremos también sobre la relación entre pruebas y observabilidad.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/NF2R-Zk9iek&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/k6&#34;&gt;Repositorio de k6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/docs/k6/latest/&#34;&gt;Documentación de k6&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>From Load Testing to Reliability Testing Tool (k6 Office Hours #92)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20230623-koh92-from-load-testing-to-reliability-testing-tool/</link>
      <pubDate>Fri, 23 Jun 2023 23:43:31 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20230623-koh92-from-load-testing-to-reliability-testing-tool/</guid>
      <description>&lt;p&gt;In this k6 Office Hours, Developer Advocates Nicole van der Hoeven and Marie Cruz talk about the evolution of k6 from a load testing tool to a reliability testing tool. They also demonstrate how to combine various modules and extensions with k6.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/N2x94S_3mNE&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Emergent Load Testing - rules for organized chaos</title>
      <link>https://nicolevanderhoeven.github.io/blog/20230419-emergent-load-testing/</link>
      <pubDate>Wed, 19 Apr 2023 00:21:06 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20230419-emergent-load-testing/</guid>
      <description>&lt;p&gt;Today I spoke at &lt;a href=&#34;https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/program/schedule/&#34;&gt;KubeCon EU 2023&lt;/a&gt; about &lt;a href=&#34;https://sched.co/1HyYH&#34;&gt;emergent load testing&lt;/a&gt;.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/Og4-Z6j_0M0&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/img_3556.jpg&#34; alt=&#34;Me just before the presentation, with the opening slide on the screen behind me.&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://slides.nicolevanderhoeven.com/2023-emergent-load-testing/#&#34;&gt;Here are the slides&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Below are some links to extensions and experimental modules that I mentioned:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/&#34;&gt;Grafana&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://k6.io/&#34;&gt;k6 site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/k6&#34;&gt;k6 repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://k6.io/docs/&#34;&gt;k6 docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://k6.io/docs/using-k6-browser/overview/&#34;&gt;k6 browser&lt;/a&gt; (experimental module)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://k6.io/docs/results-output/real-time/prometheus-remote-write/&#34;&gt;Prometheus Remote Write&lt;/a&gt; (experimental module)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://k6.io/docs/javascript-api/k6-experimental/tracing/&#34;&gt;k6 tracing&lt;/a&gt; (experimental module)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/xk6-kubernetes&#34;&gt;xk6-kubernetes&lt;/a&gt; (extension)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://k6.io/docs/javascript-api/k6-experimental/redis/&#34;&gt;k6 redis&lt;/a&gt; (experimental module)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/grafana/xk6-disruptor&#34;&gt;xk6 disruptor&lt;/a&gt; (extension)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/img_3560-1.jpg&#34; alt=&#34;Me presenting, with a slide containing my definition of emergence on the screen&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;When we write load testing scripts against our applications, we write them sequentially: A, then B, then C. But this doesn&amp;rsquo;t accurately reflect the organized chaos of a system in production, nor does it prepare the system for the unexpected.&lt;/p&gt;
&lt;p&gt;Emergence is a phenomenon where parts of a whole independently develop properties not originally present in the whole. Emergence is what helps ant workers develop roles without leadership, prompts animals to evolve adaptive traits without forethought, and facilitates non-toxic communities without moderators.&lt;/p&gt;
&lt;p&gt;The growing field of emergent software applies this swarm logic to the programs that we write. What would it take to write emergent load testing scripts? It turns out that there are a few ingredients for emergence: a large population size, opportunities to interact, feedback, and an element of control.&lt;/p&gt;
&lt;p&gt;In this talk, Nicole van der Hoeven discusses how to bring these elements to load testing by writing a script in Grafana k6 that can independently decide what requests to make next, modify Kubernetes app pods, and disrupt services based on a continual feed of results during runtime&amp;ndash; all without manual intervention. She shows how to wield this new breed of load testing to improve confidence in the complex systems we build.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/img_3558.jpg&#34; alt=&#34;Photo of the room while I was presenting&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Frontend vs. backend: How to plan your performance testing strategy</title>
      <link>https://nicolevanderhoeven.github.io/blog/20230403-frontend-vs-backend-testing/</link>
      <pubDate>Mon, 03 Apr 2023 13:20:53 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20230403-frontend-vs-backend-testing/</guid>
      <description>&lt;p&gt;&lt;em&gt;Originally posted &lt;a href=&#34;https://grafana.com/blog/2023/04/03/frontend-vs.-backend-how-to-plan-your-performance-testing-strategy/&#34;&gt;here&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;There are many aspects of application performance, but they broadly fall into two categories: frontend performance and backend performance. As a tester, it’s important to know the differences between the two and how that impacts the way you approach your tests.&lt;/p&gt;
&lt;p&gt;In this blog, I’ll provide a high-level overview of frontend performance testing and backend performance testing, including pros and cons of each one. I’ll also explain why you need both if you really want a holistic view of how your application is performing.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/xVACRP5qIJI&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&#34;why-and-where-to-use-frontend-performance-testing&#34;&gt;Why (and where) to use frontend performance testing&lt;/h2&gt;
&lt;p&gt;Frontend performance testing verifies user experience &lt;a href=&#34;https://grafana.com/blog/2023/02/10/watch-how-to-pair-grafana-faro-and-grafana-k6-for-frontend-observability/&#34;&gt;at the interface level&lt;/a&gt;. Basically, this entails everything a user sees when they access your web app, whether it’s on a laptop or other devices. This might involve automating user interactions with the site through the browser — for example, clicking on a button, filling out a form, or having scripts that load on the browser and run.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/crocs-r-cool.png&#34; alt=&#34;mockup of a site called &amp;amp;ldquo;Crocs R Cool&amp;amp;rdquo;&#34;&gt;
&lt;em&gt;In frontend testing, you&amp;rsquo;re looking at how components of the UI respond.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The metrics we analyze for frontend performance tests are typically quite different from what we use for backend testing. Let’s say we want to know the time it takes for a page to render after a user clicks on a button that directs them there. This isn’t the same thing as measuring server response time; that total round trip takes a lot more into account — things like latency or the time it takes for a client-side script to run and display the requested information.&lt;/p&gt;
&lt;h3 id=&#34;advantages-of-frontend-performance-testing&#34;&gt;Advantages of frontend performance testing&lt;/h3&gt;
&lt;p&gt;The great thing about frontend performance testing is that it provides a more realistic measurement of your end users’ experiences. They don’t care what’s going on under the hood; they care about the overall experience — and that’s exactly what frontend performance testing measures. Unlike backend performance testing, frontend performance testing looks at everything from a user’s point of view: from the time they visit a webpage to the time they can interact with something on that page.&lt;/p&gt;
&lt;p&gt;On top of that, most (about 80%) of the performance issues end users report are frontend issues. It doesn’t make much sense to skip this type of testing; it can be a critical step in finding ways to improve the overall user experience.&lt;/p&gt;
&lt;h3 id=&#34;disadvantages-of-frontend-performance-testing&#34;&gt;Disadvantages of frontend performance testing&lt;/h3&gt;
&lt;p&gt;The most obvious disadvantage of frontend testing is that it doesn’t look under the hood. If you only do frontend testing, you’re almost certain to miss something. Maybe a component isn’t working, which is creating issues for your users. But you wouldn’t know that because you’re only testing what’s visible from the browser. In other words, you might be in the situation where you know something in the application is wrong and responding too slowly, but you don’t know what.&lt;/p&gt;
&lt;p&gt;Frontend performance testing can also be quite expensive compared to, say, protocol-based testing. That’s because you need enough resources (memory and CPU) to actually spin up a browser instance and interact with your application the way that a real user would. The same load generator that could run tens of thousands of backend virtual users may only be able to run 50 frontend virtual users before running out of resources.&lt;/p&gt;
&lt;p&gt;Finally, only testing frontend performance can sometimes lead to pretty misleading results, especially as you scale. As load increases, the response time for the frontend remains fairly constant, but that’s not the case with the backend.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/Frontend-Backend-LoadTesting.png&#34; alt=&#34;graph plotting response time over the number of concurrent users for front-end and back-end&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;While the frontend component of response time remains more or less constant, the backend component of response time increases exponentially with the number of concurrent users.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This phenomenon occurs because most of the issues that frontend performance tests might identify, such as a slow-running client-side script, don’t tend to compound. It’ll be just as slow on each user’s computer regardless of how many users are running it. However, problems uncovered by backend performance testing are on the side of the application, not the users. If a database can’t keep up with 100 users sending queries to it, then 1,000 users sending it queries is likely to yield an even worse response time.&lt;/p&gt;
&lt;h2 id=&#34;why-and-where-to-use-backend-performance-testing&#34;&gt;Why (and where) to use backend performance testing&lt;/h2&gt;
&lt;p&gt;As you might have guessed at this point, backend performance testing targets the infrastructure under the hood. This could be a database that contains customer information, a payment gateway, or an authentication service for customers that have already signed up. These are things that an end user doesn’t see and maybe isn’t ever even aware of, but they still have an effect on response times.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/backend.png&#34; alt=&#34;graphic of application components&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Backend testing addresses infrastructure users might not even be aware of, like different databases, gateways, and services that underpin an application.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Scripting against the backend is quite different from scripting against the frontend. Instead of scripting user interactions like clicking, you’re scripting certain requests that are being sent on the protocol level. So, for example, you could have an HTTP GET request for the page and also for its embedded resources.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;k6/http&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt; } &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;k6&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://test.k6.io&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The sample Grafana k6 script above is an example of a simplified backend performance test. It makes a single HTTP request to retrieve the contents of &lt;a href=&#34;https://test.k6.io&#34;&gt;https://test.k6.io&lt;/a&gt;, and then waits one second.&lt;/p&gt;
&lt;p&gt;Backend performance includes things beyond just load times and latency. It includes scalability, availability, reliability, and similar attributes, so the metrics that we measure are different as well. We might look at server uptime or response times per component. We could also trace the path of a particular request through the application stack.&lt;/p&gt;
&lt;p&gt;An illustration shows that performance testing can address scalability, elasticity, availability, latency, resiliency, and reliability.
Application performance is more than just speed. Backend testing helps us verify many different aspects of performance.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/performance-ilities.png&#34; alt=&#34;diagram of different types of performance&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Application performance is more than just speed. Backend testing helps us verify many different aspects of performance.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;advantages-of-backend-performance-testing&#34;&gt;Advantages of backend performance testing&lt;/h3&gt;
&lt;p&gt;As we already discussed, frontend testing doesn’t cover everything, but it’s also more complicated than that. The 20% or so of performance bottlenecks that are backend-related can be the hardest to troubleshoot, identify, and fix. Even worse, a lot of backend performance issues can spiral out of control at higher levels of load and can be quite expensive to fix later on in a development cycle. The worst time to realize that you need to rethink your entire infrastructure is after it’s already failed in production. If you take care of backend performance testing earlier (commonly known as shifting left), it makes such pivots less costly.&lt;/p&gt;
&lt;p&gt;Another advantage of backend testing is the ability to target different components of an application. You can choose which API endpoint to hit and how hard, and you can target specific user flows, so it doesn’t always have to be end-to-end testing.&lt;/p&gt;
&lt;p&gt;And finally, backend performance tests tend to be less resource-intensive; they’re just protocol-level requests that can be easily ramped up.You don’t need to spin up a browser instance, or even parse through the Document Object Module (DOM) of a webpage or look for specific elements. It’s just a matter of sending these requests, and that’s something that you can increase the scale of pretty cheaply.&lt;/p&gt;
&lt;h3 id=&#34;disadvantages-of-backend-performance-testing&#34;&gt;Disadvantages of backend performance testing&lt;/h3&gt;
&lt;p&gt;Backend performance testing won’t tell you anything about what’s happening on the frontend, and a lot of sites these days actually use scripts that have to run on the frontend. So with backend performance testing tools, you just download those scripts. But the response time they measure is the download time, which is not really realistic because those scripts are executed. A backend performance test would fetch the text of the script. A frontend performance test would run it — and that script might do something like perform a calculation. You need frontend performance testing to measure that properly.&lt;/p&gt;
&lt;p&gt;Backend performance testing is also much more expansive than front end performance testing, especially with microservices-based applications. There are so many components to track that it can be difficult to determine where to look. You can quickly find yourself going down a rabbit hole of constant, never-ending performance tuning.&lt;/p&gt;
&lt;h2 id=&#34;frontend--backend-testing-for-the-win&#34;&gt;Frontend + backend testing for the win&lt;/h2&gt;
&lt;p&gt;So, as we’ve seen, frontend testing and backend testing both seem to have advantages and disadvantages. So which one should you use? Both, if at all possible! They look at different parts of application performance, so doing both is essential if you want a holistic view of user experience.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/frontend-vs-backend-meta.png&#34; alt=&#34;diagram of k6 being used for both frontend and backend testing&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Software teams can use Grafana k6 to address frontend and backend performance testing.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you’re operating at a smaller scale, use your own discretion about how to find the right mix for needs. But if you’re testing at a larger scale with thousands of users and you want to test both the frontend and backend aspects of application performance, I suggest you change your test strategy so the majority of the load is generated with backend performance testing scripts. That’s because of the resource intensiveness of frontend performance testing scripts, which we discussed earlier.&lt;/p&gt;
&lt;p&gt;So, if you generate most of the load with the backend and then you have a handful of frontend performance testing scripts running in the background, you should still get a good idea of how both are performing. Remember, frontend application performance remains fairly constant throughout different levels of load, so you’ll still get a lot of useful insights on both types of performance without worrying too much about the scaling costs.&lt;/p&gt;
&lt;p&gt;Frontend and backend performance both affect what your end users think of your application. If the underlying application servers respond immediately to all requests, but then a huge picture of a crocodile makes your homepage excruciatingly slow to load, then users aren’t going to like that.&lt;/p&gt;
&lt;p&gt;On the other hand, if your homepage is really sleek and quick to load, but the application server hasn’t responded with the data that the browser needs to render, then users aren’t going to like that either.&lt;/p&gt;
&lt;p&gt;A common problem when testing both frontend and backend performance is script duplication: because of the differences in the two approaches, you often have to use two separate tools — which means two test suites and potentially two scripting languages. While this is a valid approach, it’s more sustainable to look for a tool that can target both types of performance, such as k6.&lt;/p&gt;
&lt;p&gt;Whichever tool(s) you end up using, testing both frontend and backend performance is going to give you the clearest view of how your application really performs.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The easiest way to get started with k6 is through Grafana Cloud k6. The free tier includes 500 virtual user hours/month for k6 testing and more. &lt;a href=&#34;https://grafana.com/auth/sign-up/create-user?pg=blog&amp;amp;plcmt=body-txt&#34;&gt;Sign up for free now!&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Guide to Load Testing Websites</title>
      <link>https://nicolevanderhoeven.github.io/blog/20230112-load-testing-websites/</link>
      <pubDate>Thu, 12 Jan 2023 17:12:42 +0000</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20230112-load-testing-websites/</guid>
      <description>&lt;p&gt;&lt;em&gt;Original article &lt;a href=&#34;https://k6.io/docs/testing-guides/load-testing-websites/&#34;&gt;here&lt;/a&gt;, written for k6.io&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This doc explains some key concepts about load testing websites, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The difference between backend and frontend performance testing&lt;/li&gt;
&lt;li&gt;When to choose between protocol-based, browser-based, or hybrid scripts&lt;/li&gt;
&lt;li&gt;Recommended practices about how to load test websites&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All load tests try to simulate real user traffic  to prevent failures, improve reliability, and release new code with confidence.
But your approach to load testing must adapt to the type of application you want to test.&lt;/p&gt;
&lt;p&gt;In this guide, learn about strategies to test websites, including specific recommendations for complex scenario scripting and test execution.&lt;/p&gt;
&lt;h2 id=&#34;load-testing-approaches&#34;&gt;Load testing approaches&lt;/h2&gt;
&lt;p&gt;When you approach the load test, first consider the following perspectives:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Backend vs. frontend performance&lt;/li&gt;
&lt;li&gt;Protocol-based, browser-based, or hybrid load testing&lt;/li&gt;
&lt;li&gt;Component testing vs. end-to-end testing&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;backend-vs-frontend-performance&#34;&gt;Backend vs. frontend performance&lt;/h2&gt;
&lt;p&gt;Performance has a significant influence on the user experience of a website.&lt;/p&gt;
&lt;p&gt;For example, when users want to visualize or interact with some information, they expect the website to react quickly.&lt;/p&gt;
&lt;p&gt;To measure performance, testers often look at response times, which are affected by two main factors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Frontend performance&lt;/li&gt;
&lt;li&gt;Backend performance&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;frontend-performance&#34;&gt;Frontend performance&lt;/h3&gt;
&lt;p&gt;Frontend performance testing verifies application performance on the interface level, measuring round-trip metrics that consider how and when page elements appear on the screen. It&amp;rsquo;s concerned with the end-user experience of an application, usually involving a browser.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/frontend-rendering.png&#34; alt=&#34;Snapshots over time of webpage elements rendering on a browser&#34; title=&#34;Snapshots over time of webpage elements rendering on a browser&#34;&gt;&lt;/p&gt;
&lt;p&gt;Frontend performance testing excels at identifying issues on a micro level but does not expose issues in the underlying architecture of a system.&lt;/p&gt;
&lt;p&gt;Because it primarily measures a single user&amp;rsquo;s experience of the system, frontend performance testing tends to be easier to run on a small scale.
Frontend performance testing has metrics that are distinct from backend performance testing. Frontend performance tests for things like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Whether the pages of the application are optimized to render quickly on a user&amp;rsquo;s screen&lt;/li&gt;
&lt;li&gt;How long it takes a user to interact with the UI elements of the application.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some concerns when doing this type of performance testing are its dependency on fully integrated environments and the cost of scaling. You can test frontend performance only once the application code and infrastructure have been integrated with a user interface. Tools to automate frontend testing are also inherently more resource-intensive, so they can be costly to run at scale and are not suitable for high load tests.&lt;/p&gt;
&lt;h3 id=&#34;backend-performance&#34;&gt;Backend performance&lt;/h3&gt;
&lt;p&gt;Backend performance testing targets the underlying application servers to see how they behave under production-like conditions. When it comes to websites, while frontend performance involves how assets included in the page are rendered, backend performance focuses on how those assets are processed by the application servers, served to users, and downloaded by browsers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/backend-performance.png&#34; alt=&#34;Backend components&#34; title=&#34;Backend components of an application&#34;&gt;&lt;/p&gt;
&lt;p&gt;Backend testing is broader in scope than frontend performance testing. API testing can be used to target specific components or integrated components, meaning that application teams have more flexibility and higher chances of finding performance issues earlier. Backend testing is less resource-intensive than frontend performance testing and is thus more suitable for generating high load.&lt;/p&gt;
&lt;h3 id=&#34;which-one-should-you-test&#34;&gt;Which one should you test?&lt;/h3&gt;
&lt;p&gt;It depends! Ideally, both.&lt;/p&gt;
&lt;p&gt;Frontend testing tools are executed on the client side and are limited in scope: they do not provide enough information about backend components for fine-tuning beyond the user interface.&lt;/p&gt;
&lt;p&gt;This limitation can lead to false confidence in overall application performance when the amount of traffic against an application increases. While the frontend component of response time remains more or less constant, the backend component of response time increases exponentially with the number of concurrent users:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/Frontend-Backend-LoadTesting.png&#34; alt=&#34;Backend performance often contributes significantly to overall user experience&#34; title=&#34;Backend performance often contributes significantly to overall user experience&#34;&gt;&lt;/p&gt;
&lt;p&gt;Testing &lt;em&gt;only&lt;/em&gt; frontend performance ignores a large part of the application, one more susceptible to increased failures and performance bottlenecks at higher levels of load.&lt;/p&gt;
&lt;p&gt;Testing &lt;em&gt;only&lt;/em&gt; backend performance, on the other hand, ignores &amp;ldquo;the first mile&amp;rdquo; of user experience and breadth. Backend testing involves messaging at the protocol level rather than interacting with page elements the way a real user would. It verifies the foundation of an application rather than the highest layer of it that a user ultimately sees.&lt;/p&gt;
&lt;p&gt;Testing both frontend and backend performance leads to the best overall performance and user experience for your application. Ignoring one or the other exposes you to performance bottlenecks that significantly decrease a user&amp;rsquo;s satisfaction with your application.&lt;/p&gt;
&lt;p&gt;However, if your testing is smaller in scope, you can choose to focus on either frontend or backend with the goal of eventually building a test suite that encompasses both.&lt;/p&gt;
&lt;h2 id=&#34;component-testing-vs-end-to-end-testing&#34;&gt;Component testing vs. end-to-end testing&lt;/h2&gt;
&lt;p&gt;When you&amp;rsquo;re testing a web app, you may wonder whether how you structure your test scripts. Consider the following two methods.&lt;/p&gt;
&lt;h3 id=&#34;component-testing&#34;&gt;Component testing&lt;/h3&gt;
&lt;p&gt;One way you could load test a web app is to load test its components. Maybe you know there are issues with a specific functionality due to previous production issues, or maybe you&amp;rsquo;d like to target components that are business-critical to reduce risk exposure.&lt;/p&gt;
&lt;p&gt;In these cases, the type of test you write may:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;be protocol-based&lt;/li&gt;
&lt;li&gt;call only those API endpoints that are relevant&lt;/li&gt;
&lt;li&gt;have smaller or no sleep/think time&lt;/li&gt;
&lt;li&gt;be focused on eventually stress testing a component or service or finding its breaking point&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Testing in this way is more flexible. With protocol testing, you can specify the endpoints or servers you&amp;rsquo;d like to hit, and narrow your test&amp;rsquo;s target that way. You can test specific functionalities while skipping others that come chronologically before it in a standard user flow. You can more finely control the type of traffic that is generated. If you&amp;rsquo;re recreating a specific mix of requests, you can script those requests and reproduce them in a repeatable manner.&lt;/p&gt;
&lt;p&gt;Doing component testing for load may not always require that your script behave like an end user. In fact, it may be necessary to artificially inflate traffic to more quickly reproduce issues, or to deflate traffic to reduce the noise in the logs. By the nature of this type of testing, scripts don&amp;rsquo;t contain the full flow of a request that you would expect to see in production, so realism is not a priority.&lt;/p&gt;
&lt;h3 id=&#34;end-to-end-testing&#34;&gt;End-to-end testing&lt;/h3&gt;
&lt;p&gt;You could also do end-to-end testing against a web app. End-to-end testing seeks to replicate real user behaviour and track its effects across the entire stack. When doing end-to-end testing, you might:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;do protocol-level, browser-level, or hybrid load testing&lt;/li&gt;
&lt;li&gt;replicate the actions in a typical user flow&lt;/li&gt;
&lt;li&gt;think about the performance of the entire workflow as well as how long a request took to be processed by each component&lt;/li&gt;
&lt;li&gt;write scripts that access the application the same way users would, such as by browsing to the homepage before finding their way to other parts of the website&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This type of load testing is broader in scope than component testing, but shallower in terms of depth. With end-to-end testing, you get a better idea of the full user experience of the application as a whole. However, it can also be more complex to troubleshoot, as you have more components to monitor and more places to look for issues that are found.&lt;/p&gt;
&lt;p&gt;End-to-end testing is based on real user behavior, so it&amp;rsquo;s often important that end-to-end test scripts also be realistic.&lt;/p&gt;
&lt;h2 id=&#34;protocol-based-browser-based-or-hybrid-load-testing&#34;&gt;Protocol-based, browser-based, or hybrid load testing&lt;/h2&gt;
&lt;p&gt;The decision of whether to test the frontend, backend, or both will also affect the type of load testing you should carry out and the kind of scripts you should write.&lt;/p&gt;
&lt;h3 id=&#34;protocol-based-load-testing&#34;&gt;Protocol-based load testing&lt;/h3&gt;
&lt;p&gt;Protocol-based load testing verifies the backend performance of an application by simulating the requests underlying user actions. For websites, this commonly involves HTTP requests that bypass the user interface of your application and are sent directly to a server or application component.&lt;/p&gt;
&lt;p&gt;For example, a protocol-based load testing script might request all the resources on a webpage from the application servers, but those resources are merely downloaded. The response times reported by a purely protocol-based script do not include frontend metrics such as the time taken for images to render on a browser. The load is generated by simulating many requests sent to application servers.&lt;/p&gt;
&lt;p&gt;While protocol-based load testing may seem to lend itself better to component testing, you can also do end-to-end website testing with protocol-level scripts.&lt;/p&gt;
&lt;h4 id=&#34;sample-protocol-based-test-script&#34;&gt;Sample protocol-based test script&lt;/h4&gt;
&lt;p&gt;The following is an example of a protocol-based load testing script in k6 that fetches the homepage, along with resources embedded into the page.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;k6/http&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;check&lt;/span&gt; } &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;k6&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Homepage&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;params&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sec-ch-ua&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#34;Chromium&amp;#34;;v=&amp;#34;94&amp;#34;, &amp;#34;Google Chrome&amp;#34;;v=&amp;#34;94&amp;#34;, &amp;#34;;Not A Brand&amp;#34;;v=&amp;#34;99&amp;#34;&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;accept-encoding&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;gzip, deflate, br&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;accept-language&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;en-GB,en;q=0.9&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 01. Go to the homepage
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;responses&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;batch&lt;/span&gt;([
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://mywebsite.com/&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;params&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://mywebsite.com/style.min.css&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;params&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://website.com/header.png&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;params&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://website.com/polyfill.min.js&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;params&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;check&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;responses&lt;/span&gt;, {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Homepage loaded&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;) =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;JSON&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;stringify&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;includes&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Welcome to my site&amp;#39;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 02. View products
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;responses&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;batch&lt;/span&gt;([
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://mywebsite.com/products&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;params&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://mywebsite.com/style.css&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;params&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://website.com/product1.jpg&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;params&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://website.com/product2.jpg&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;params&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://website.com/displaylist.js&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;params&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;check&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;responses&lt;/span&gt;, {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Products loaded&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;) =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;JSON&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;stringify&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;includes&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Add to Cart&amp;#39;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://k6.io/docs/test-authoring/recording-a-session/browser-recorder/&#34;&gt;Recording browser traffic&lt;/a&gt; helps you prototype to test websites on the protocol level.&lt;/p&gt;
&lt;h3 id=&#34;browser-based-load-testing&#34;&gt;Browser-based load testing&lt;/h3&gt;
&lt;p&gt;Browser-based load testing verifies the frontend performance of an application by simulating real users using a browser to access your website.&lt;/p&gt;
&lt;p&gt;For example, a browser-based load testing script might include instructions to navigate to a page, click on a button, and type out text on a form. Those user actions then trigger underlying requests on the protocol layer, but only user actions are scripted in browser-based testing.&lt;/p&gt;
&lt;p&gt;Unlike protocol-based load testing, browser-based load testing scripts generate load by starting multiple instances of browsers and interacting with your application the way real users would. Testing at the browser level can also be the only option for testing Single-Page Applications where a lot of the application logic is executed by client-side scripts.&lt;/p&gt;
&lt;p&gt;Scripting on the browser level usually requires the use of different tools from the ones used to test at the protocol level.
However, k6 has an extension called &lt;a href=&#34;https://k6.io/docs/javascript-api/xk6-browser/&#34;&gt;xk6-browser&lt;/a&gt; that allows the creation of browser-based test scripts alongside protocol-based ones.&lt;/p&gt;
&lt;h4 id=&#34;sample-browser-based-test-script&#34;&gt;Sample browser-based test script&lt;/h4&gt;
&lt;p&gt;The following is an example of a browser-based load testing script in k6 using xk6-browser on a dummy website. Instead of making an HTTP request, the script views the homepage, then looks for and clicks on a link to the product page.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;chromium&lt;/span&gt; } &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;k6/x/browser&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt; } &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;k6&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;browser&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chromium&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;launch&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;headless&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;page&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;browser&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;newPage&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 01. Go to the homepage
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;page&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://mywebsite.com&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;waitUntil&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;networkidle&amp;#39;&lt;/span&gt; })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(() =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;page&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;waitForSelector&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;p[class=&amp;#34;woocommerce-result-count&amp;#34;]&amp;#34;]&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;page&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;screenshot&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;screenshots/01_homepage.png&amp;#39;&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// 02. View products
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;page&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a[class=&amp;#34;woocommerce-LoopProduct-link woocommerce-loop-product__link&amp;#34;]&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;click&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;page&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;waitForSelector&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;button[name=&amp;#34;add-to-cart&amp;#34;]&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;page&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;screenshot&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;screenshots/02_view-product.png&amp;#39;&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt;(() =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;page&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;browser&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;close&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;tips-for-writing-browser-level-scripts&#34;&gt;Tips for writing browser-level scripts&lt;/h4&gt;
&lt;p&gt;The following steps can help you get started with a browser-level test script.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Script user actions, not requests.&lt;/strong&gt; Determine what a user might do for a particular task, and script interactions with elements on the browser level. For example, script what buttons the user clicks on.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Identify unique selectors.&lt;/strong&gt; Once you have identified which page elements a user interacts with, use the Element Inspector for DevTools in your browser to find a unique, static, and simple way to identify each element. The script needs selectors to find the right element to interact with.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use elements to verify responses.&lt;/strong&gt; After every action, use &lt;a href=&#34;https://k6.io/docs/javascript-api/xk6-browser/api/locator/&#34;&gt;locators&lt;/a&gt; to search for elements on the page that you would expect to find. This verification helps ensure that the script has reached the expected page.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Take screenshots for every action while debugging.&lt;/strong&gt; One of the advantages of browser-based testing is the ability to take screenshots. After every user interaction the script simulates, use &lt;a href=&#34;https://k6.io/docs/javascript-api/xk6-browser/api/page/&#34;&gt;page.screenshot&lt;/a&gt; to save a visual image of what the script encountered for later troubleshooting.&lt;/p&gt;
&lt;h3 id=&#34;hybrid-load-testing&#34;&gt;Hybrid load testing&lt;/h3&gt;
&lt;p&gt;Hybrid load testing is a combination of protocol-based and browser-based load testing. While you can use two tools or two scripts to execute different types of load tests (one protocol-based and one browser-based), having both types of tests executed by the same script and the same tool is ideal. Aggregating results between different tools can be difficult at best and inconsistent at worst.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/hybrid-testing.png&#34; alt=&#34;Hybrid of frontend and backend performance testing&#34; title=&#34;In hybrid load testing, both the frontend and backend are tested&#34;&gt;&lt;/p&gt;
&lt;p&gt;A best practice in hybrid load testing is to generate most of the load using the protocol-level test, and then to run a smaller number of the browser-level testing scripts. This approach:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reduces the number of load generators needed, since protocol-level testing requires fewer machines to generate the same load&lt;/li&gt;
&lt;li&gt;measures backend and frontend performance in the same test execution&lt;/li&gt;
&lt;li&gt;provides a single source of aggregated output at the end&lt;/li&gt;
&lt;li&gt;reduces complexity in the creation and maintenance of scripts&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;scripting-considerations&#34;&gt;Scripting considerations&lt;/h2&gt;
&lt;p&gt;When you script a test for a website, consider these recommendations.&lt;/p&gt;
&lt;h3 id=&#34;consider-factors-that-affect-script-realism&#34;&gt;Consider factors that affect script realism&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Record your user journey.&lt;/strong&gt;  Using the browser recorder can facilitate initial test script creation by capturing all the embedded resources on webpages. Check out the &lt;a href=&#34;https://k6.io/docs/test-authoring/recording-a-session&#34;&gt;Session Recording guide&lt;/a&gt; to learn more about how to auto-generate your load test from a user session.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Correlate data.&lt;/strong&gt; Recordings often don&amp;rsquo;t take into account dynamic values that are generated anew each time a request is made. Go through the recorded requests and determine whether you need to &lt;a href=&#34;https://k6.io/docs/examples/correlation-and-dynamic-data/&#34;&gt;extract values from previous responses&lt;/a&gt; and use parameters in subsequent requests. This practice ensures your VUs behave more like real users would.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Include or exclude static resources.&lt;/strong&gt; Determine whether you should include or exclude static resources on pages such as images, JavaScript, etc. Consider including them if you want to measure overall user experience. Consider excluding them if you are using a Content Delivery Network (CDN) that is under a separate Service Level Agreement (SLA).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exclude third-party requests.&lt;/strong&gt; Don&amp;rsquo;t load test servers that you don&amp;rsquo;t own. Many applications make calls to third-party providers for authentication, social sharing, and marketing analytics. Disable these requests unless you have permission to include them in your tests.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use concurrent requests.&lt;/strong&gt; To mimic the way modern browsers download some requests in parallel, use &lt;a href=&#34;https://k6.io/docs/javascript-api/k6-http/batch/&#34;&gt;batching&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Determine cache and cookie behaviour.&lt;/strong&gt;  k6 automatically resets cookies between iterations, but you can also &lt;a href=&#34;https://k6.io/docs/using-k6/k6-options/reference/#no-cookies-reset&#34;&gt;change this behavior&lt;/a&gt; if maintaining cookies would be more realistic.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use dynamic think time and pacing.&lt;/strong&gt;  Consider adding varying &lt;a href=&#34;https://k6.io/docs/javascript-api/k6/sleep/&#34;&gt;delays&lt;/a&gt; so you don&amp;rsquo;t artificially stagger a script with completely uniform delays.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use test data.&lt;/strong&gt; Real users typically don&amp;rsquo;t search for or submit the same data repeatedly. Consider adding a &lt;a href=&#34;https://k6.io/docs/examples/data-parameterization/&#34;&gt;test data file&lt;/a&gt; for the script to iterate through.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Model test parameters and load profile after production.&lt;/strong&gt; In k6, you can use &lt;a href=&#34;https://k6.io/docs/using-k6/k6-options/how-to&#34;&gt;test options&lt;/a&gt; to determine the exact shape and profile of your load test script. Select the appropriate &lt;a href=&#34;https://k6.io/docs/using-k6/scenarios/executors/&#34;&gt;executors&lt;/a&gt; for the job.&lt;/p&gt;
&lt;h3 id=&#34;create-a-reusable-framework&#34;&gt;Create a reusable framework&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Use tags and groups.&lt;/strong&gt; Organizing requests by &lt;a href=&#34;https://k6.io/docs/using-k6/tags-and-groups/&#34;&gt;tagging and grouping them&lt;/a&gt; helps you consolidate like metrics and makes your test scripts more understandable by others.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use scenarios.&lt;/strong&gt; When combining protocol-based and browser-based tests, use &lt;a href=&#34;https://k6.io/docs/using-k6/scenarios/&#34;&gt;scenarios&lt;/a&gt; to independently control their test parameters and &lt;a href=&#34;https://k6.io/docs/using-k6/scenarios/executors/&#34;&gt;executors&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modularize scripts.&lt;/strong&gt; Use &lt;a href=&#34;https://k6.io/docs/using-k6/modules/&#34;&gt;modules&lt;/a&gt; to separate and organize functions for protocol-level testing and browser-level testing, and then use a test runner script to execute them. This approach means different scripts can be versioned and changed without affecting each other.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Integrate your tests into your CI pipeline.&lt;/strong&gt; Adopting a &amp;ldquo;tests as code&amp;rdquo; approach enables you to tie your load tests more closely into your project&amp;rsquo;s existing CI/CD processes, helping you get the most value out of every test.&lt;/p&gt;
&lt;h3 id=&#34;test-with-thresholds-in-mind&#34;&gt;Test with thresholds in mind&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Create thresholds for both types of testing.&lt;/strong&gt; Some browser-level and protocol-level metrics cannot be combined because they don&amp;rsquo;t measure the same thing. Set &lt;a href=&#34;https://k6.io/docs/using-k6/thresholds/&#34;&gt;thresholds&lt;/a&gt; for relevant metrics from both the browser-level script and the protocol-level one.&lt;/p&gt;
&lt;h3 id=&#34;when-possible-use-hybrid-load-testing&#34;&gt;When possible, use hybrid load testing&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Use protocol-based scripts to generate majority of the load.&lt;/strong&gt; When writing the test scenario, use the protocol-based requests to simulate most of the traffic and use fewer VUs for the browser-based requests. Relying on the protocol-level traffic helps keep resource utilization on load generators down.&lt;/p&gt;
&lt;h2 id=&#34;execution-considerations&#34;&gt;Execution considerations&lt;/h2&gt;
&lt;p&gt;When you run tests, consider the test environment and the load generator location.&lt;/p&gt;
&lt;h3 id=&#34;run-your-tests-in-the-appropriate-environment&#34;&gt;Run your tests in the appropriate environment&lt;/h3&gt;
&lt;p&gt;Testing in pre-production environments and in production environments both add value.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testing in pre-production environments&lt;/strong&gt; (staging, test, system integration testing, user acceptance testing, and production replica environments) enables you to identify performance defects early, which can save a lot of time and effort (and reputation) later on. Running in test environments also means you can often afford to be more aggressive with your tests. However, it&amp;rsquo;s also more critical to get your load profiles right, and the test results you get may not necessarily apply to production.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testing in production&lt;/strong&gt; yields the most accurate results, but it&amp;rsquo;s also more risky. Often, testing production is the only feasible alternative. You can reduce the risk of impact to real customers while testing in production by using lower levels of load when running load tests during peak hours, schedule tests for off-peak hours, choosing load test types that are less risky, using techniques like synthetic monitoring that generate less traffic, using real user monitoring tools to get snapshots of user performance at load, and ensuring that your observability stack is working at peak efficiency.&lt;/p&gt;
&lt;h3 id=&#34;run-tests-where-your-customers-are&#34;&gt;Run tests where your customers are&lt;/h3&gt;
&lt;p&gt;The location of the load generator(s), where the traffic is coming &lt;em&gt;from&lt;/em&gt;, can also have an impact on your test results. The question is: where are your end users located?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;On-premises load testing&lt;/strong&gt; can be ideal when testing early on in the development a website, or when there are machines that can be repurposed as load generators. However, testing entirely from within a corporate network may also yield false positives, in that response times reported are significantly lower than if the same application servers were accessed from across the country.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Load testing on the cloud&lt;/strong&gt; is an essential part of the testing strategy for many public-facing websites. Using load generators on the cloud gives you access to test in different states and geographical countries, creating a mix of load generators proportional to your users&amp;rsquo; locations. Cloud load generators are easier to provision and cheaper to maintain in the long run than on-premise ones. Load testing on the cloud can help you include the effects of network latency in your tests and yield results that are more realistic.&lt;/p&gt;
&lt;h2 id=&#34;recommendations&#34;&gt;Recommendations&lt;/h2&gt;
&lt;p&gt;Here are some recommendations to help you plan, script, and execute your load tests for websites.&lt;/p&gt;
&lt;p&gt;If you want to test the last-mile user experience of your website:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;focus on &lt;strong&gt;frontend performance&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;write &lt;strong&gt;browser-based test scripts&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;and consider doing more realistic &lt;strong&gt;end-to-end&lt;/strong&gt; tests of the user flow.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to test the underlying infrastructure of your website:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;focus on &lt;strong&gt;backend performance&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;write &lt;strong&gt;protocol-based test scripts&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;and consider starting with &lt;strong&gt;component testing&lt;/strong&gt; and then gradually increasing the scope.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If your website is meant for internal or has limited access:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;strong&gt;on-premise load generators&lt;/strong&gt; located within the network that most of your users access the website from.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If your website is external and public-facing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;strong&gt;cloud load generators&lt;/strong&gt; in the load zones where your users reside.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Test in &lt;strong&gt;pre-production environments&lt;/strong&gt; when you can, but also consider &lt;strong&gt;testing in production&lt;/strong&gt; in a limited capacity.&lt;/p&gt;
&lt;p&gt;Load testing websites can be complex due to the number of viable testing approaches available, the scope for performance testing, and the potential effects of releasing undertested code. By following the recommendations we&amp;rsquo;ve put forward here, you can tailor your testing more closely to your objectives.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Distributed Tracing With Grafana k6 (k6 Office Hours #70)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20221104-koh70-distributed-tracing-with-grafana-k6/</link>
      <pubDate>Fri, 04 Nov 2022 14:03:04 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20221104-koh70-distributed-tracing-with-grafana-k6/</guid>
      <description>&lt;p&gt;Just announced: distributed tracing with Grafana k6 x Tempo! Daniel González Lopes joins us to talk about what distributed tracing is, and how traces using the Tempo backend could help you troubleshoot your performance issues and improve overall reliability. This new integration was just announced at ObservabilityCon 2022, and Daniel&amp;rsquo;s here to tell us all about it!&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/g9xU_pFr-Vc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/blog/2022/11/03/how-to-correlate-performance-testing-and-distributed-tracing-to-proactively-improve-reliability/&#34;&gt;Blog post on k6 x Tempo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/blog/2022/11/02/observabilitycon-2022-announcements&#34;&gt;Other announcements from ObservabilityCON 2022&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>All About Load Testing Metrics (k6 Office Hours #69)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20221028-koh69-all-about-metrics/</link>
      <pubDate>Fri, 28 Oct 2022 15:00:07 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20221028-koh69-all-about-metrics/</guid>
      <description>&lt;p&gt;Leandro Melendez and Nicole van der Hoeven discuss all about load testing metrics. What do they all mean? Which ones do you REALLY need? Understanding metrics and analysing test results is arguably the most important part of a load test&amp;ndash; and also the most difficult! We&amp;rsquo;re answering all the questions you ever had about the many metrics that come with load and performance testing.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/c3mNes0BxG8&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Assertions in k6 (k6 Office Hours #68)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20221021-koh68-assertions-in-k6/</link>
      <pubDate>Fri, 21 Oct 2022 16:29:35 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20221021-koh68-assertions-in-k6/</guid>
      <description>&lt;p&gt;How do you do assertions in k6? CTO Pawel Suwala talks about different ways to implement BDD/TDD in k6, including an assertion library called k6chaijs. We also discuss the differences between checks, thresholds, and assertions.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/k98Ej3xvTQM&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&#34;related-articles&#34;&gt;Related articles&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nicolevanderhoeven.github.io/blog/20220422-koh-51-end-to-end-browser-testing-with-k6/&#34;&gt;End-to-end browser testing using xk6-browser&lt;/a&gt; (k6 Office Hours #51)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://notes.nicolevanderhoeven.com/Browser-based+testing&#34;&gt;Browser-based testing&lt;/a&gt; (notes)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nicolevanderhoeven.github.io/blog/20211112-koh35-browser-testing-and-api-load-testing-with-k6/&#34;&gt;Browser testing and API load testing in the same script with k6&lt;/a&gt; (k6 Office Hours #35)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nicolevanderhoeven.github.io/blog/20220210-in-search-of-the-best-pokemon/&#34;&gt;In search of the best Pokémon: Browser automation and load testing in one script with k6&lt;/a&gt; (presentation at Automation Guild 2022)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nicolevanderhoeven.github.io/blog/20220315-real-browser-testing-with-xk6-browser/&#34;&gt;Real browser testing with xk6-browser&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Load Testing Types and k6 Executors (k6 Office Hours #67)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20221014-koh67-load-testing-types-and-k6-executors/</link>
      <pubDate>Fri, 14 Oct 2022 18:36:55 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20221014-koh67-load-testing-types-and-k6-executors/</guid>
      <description>&lt;p&gt;What are the different load testing types, and how do they relate to the k6 executors? We go through every single k6 executor and how, when, and why you should use each one in this week&amp;rsquo;s episode of k6 Office Hours.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/ypli_y3UryU&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>All About Web Performance (k6 Office Hours #66)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20221007-koh66-all-about-web-performance/</link>
      <pubDate>Fri, 07 Oct 2022 17:25:24 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20221007-koh66-all-about-web-performance/</guid>
      <description>&lt;p&gt;My fellow Developer Advocate and tester Marie Cruz and I talk all about web performance and best practices for making websites faster. What&amp;rsquo;s the difference between performance testing a website vs. an API? What are some things you should keep in mind when testing a web app?&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/gYfUoX85ElA&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Performance testing for beginners (k6 Office Hours #65)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220930-koh65-performance-testing-for-beginners/</link>
      <pubDate>Fri, 30 Sep 2022 12:45:08 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220930-koh65-performance-testing-for-beginners/</guid>
      <description>&lt;p&gt;My colleague &lt;a href=&#34;https://javaducky.com&#34;&gt;Paul Balogh&lt;/a&gt; and I interview the k6 technical writer, Matt Dodson, who asks all the questions about load and performance testing that you were always afraid to ask.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/oNWigNvQ9Tg&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>The future of k6 (k6 Office Hours #64)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220923-koh64-future-of-k6/</link>
      <pubDate>Fri, 23 Sep 2022 12:18:07 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220923-koh64-future-of-k6/</guid>
      <description>&lt;p&gt;We&amp;rsquo;re talking about the future of k6 with CEO Robin Gustafsson and CTO Pawel Suwala. What&amp;rsquo;s next for k6? What new features are we working on? What&amp;rsquo;s the plan for further integrations with Grafana? What are the plans for the k6 team as we transition out of the honeymoon period after the Grafana acquisition?&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/r1kj3oGHDmo&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Getting started with xk6-browser (k6 Office Hours #63)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220916-koh63-getting-started-with-xk6-browser/</link>
      <pubDate>Fri, 16 Sep 2022 12:13:33 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220916-koh63-getting-started-with-xk6-browser/</guid>
      <description>&lt;p&gt;Marie Drake, the newest Developer Advocate to join the k6 team, shares her experience in getting started with xk6-browser: how to install it, issues she encountered, and the state of browser testing with k6 as she sees it.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/CRSTQ6n05hM&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Load Testing Apache Kafka using k6 (k6 Office Hours #62)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220909-koh62-load-testing-apache-kafka/</link>
      <pubDate>Fri, 09 Sep 2022 12:09:36 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220909-koh62-load-testing-apache-kafka/</guid>
      <description>&lt;p&gt;Senior Software Engineer Mostafa Moradian joins us to talk about load testing Apache Kafka using k6 and the extension he created, called xk6-kafka. He describes what Kafka is, the basics of Kafka, and why he thinks load testing it is important. Mostafa works on the backend team at k6/Grafana Labs.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/NQ0fyhq1mxo&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Resilience and Chaos Testing with SteadyBit and k6 (k6 Office Hours #61)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220902-koh61-resilience-and-chaos-testing-with-steadybit-and-k6/</link>
      <pubDate>Fri, 02 Sep 2022 16:56:14 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220902-koh61-resilience-and-chaos-testing-with-steadybit-and-k6/</guid>
      <description>&lt;p&gt;What is the difference between resilience testing and chaos testing? SteadyBit CEO and co-founder Benjamin Wilms talks about how to integrate SteadyBit with k6 for both resilience and chaos, and why he prefers &amp;ldquo;chaos testing&amp;rdquo; to &amp;ldquo;chaos engineering&amp;rdquo;.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/GhyKF7oP21M&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>What Is Grafana Mimir? (k6 Office Hours #53)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220506-koh53-what-is-grafana-mimir/</link>
      <pubDate>Fri, 06 May 2022 17:00:28 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220506-koh53-what-is-grafana-mimir/</guid>
      <description>&lt;p&gt;Maintainer Marco Pracucci talks about the new Grafana project, Mimir, a next-generation time-series database for Prometheus. He joins Developer Advocates Nicole van der Hoeven and Paul Balogh to talk about what Mimir is, why it was needed, and how he helped scale it using k6.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/2P1UViYf1mQ&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>API load testing using k6, with Tom Miseur (k6 Office Hours #52)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220429-koh52-api-load-testing-using-k6/</link>
      <pubDate>Fri, 29 Apr 2022 17:00:26 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220429-koh52-api-load-testing-using-k6/</guid>
      <description>&lt;p&gt;In this second part of demonstrating the dogfooding we do at k6, I talk to Tom Miseur, Technical Specialist, who shows how he wrote API load testing scripts with k6 to test k6 Cloud&amp;ndash; and what his results were after his testing.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/D8Ax-ONLJLo&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>End-to-end browser testing using xk6-browser, with Thomas Wikman (k6 Office Hours #51)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220422-koh-51-end-to-end-browser-testing-with-k6/</link>
      <pubDate>Fri, 22 Apr 2022 17:00:12 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220422-koh-51-end-to-end-browser-testing-with-k6/</guid>
      <description>&lt;p&gt;Have you ever wondered how to test a platform built for testing other products? Our frontend developer, Thomas Wikman, joins us on k6 Office Hours to talk about his experience being a user of one of our tools - xk6-browser - and how he uses it to test the entire k6 Cloud frontend.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/UtMJfasNjSY&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Load testing results in the k6 Cloud App for Grafana, with Edgar Fisher (k6 Office Hours #49)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220408-koh-49-load-testing-results-in-k6-cloud-app/</link>
      <pubDate>Fri, 08 Apr 2022 18:00:18 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220408-koh-49-load-testing-results-in-k6-cloud-app/</guid>
      <description>&lt;p&gt;There are many ways to get k6 load testing results into Grafana, but our frontend software engineer, Edgar Fisher, talks to us about the easiest way of them all: the new k6 Cloud App for Grafana.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/bt6civUmHUU&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Building Reliable Systems With k6 (k6 Office Hours #48)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220401-koh48-building-reliable-systems-with-k6/</link>
      <pubDate>Fri, 01 Apr 2022 10:02:29 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220401-koh48-building-reliable-systems-with-k6/</guid>
      <description>&lt;p&gt;In this week&amp;rsquo;s k6 Office Hours, my colleague Pandurovic, an engineering manager/backend lead at k6, joined &lt;a href=&#34;https://twitter.com/javaducky&#34;&gt;Paul Balogh&lt;/a&gt; and me to talk about how k6 works on the backend, and how the backend team is working to make it even more reliable.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/Eex7KHNaxeU&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>How to Analyze Load Testing Results with k6 (k6 Office Hours #47</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220325-koh47-how-to-analyze-load-testing-results-with-k6/</link>
      <pubDate>Fri, 25 Mar 2022 18:00:56 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220325-koh47-how-to-analyze-load-testing-results-with-k6/</guid>
      <description>&lt;p&gt;In this k6 Office Hours, Paul Balogh and I discuss the different ways to turn k6 metrics into graphs for analyzing performance testing results.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/IW7I_vWV93A&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Load Testing for DevOps with Victor Farcic (k6 Office Hours #45)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220311-koh45-load-testing-for-devops/</link>
      <pubDate>Fri, 11 Mar 2022 11:12:52 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220311-koh45-load-testing-for-devops/</guid>
      <description>&lt;p&gt;How can you use load testing for DevOps? What kind of performance testing can or should be included in CI/CD pipelines? Viktor Farcic from Upbound and DevOps Toolkit join Nicole van der Hoeven and Paul Balogh to discuss how he sees k6 fitting into the daily duties of a DevOps engineer.&lt;/p&gt;
&lt;p&gt;{{ youtube xUlNdsr6y_E }}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Private Load Zones for Load Testing (k6 Office Hours #44)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220304-koh44-private-load-zones-for-load-testing/</link>
      <pubDate>Fri, 04 Mar 2022 10:01:57 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220304-koh44-private-load-zones-for-load-testing/</guid>
      <description>&lt;p&gt;Load testing on the cloud definitely has its advantages, but what if you need to load test behind a firewall? Here to talk about using private load zones in k6 are k6 CTO Pawel Suwala and k6 Backend Lead Samuel Regandell. Private load zones are a new feature of k6 Cloud that will allow you to run load tests against applications that are not publicly accessible and also use your own AWS account to generate the load.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/sqKc95zdXyI&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>In search of the best Pokémon: Browser automation and load testing in one script with k6 (Automation Guild 2022)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220210-in-search-of-the-best-pokemon/</link>
      <pubDate>Thu, 10 Feb 2022 12:01:53 +0200</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220210-in-search-of-the-best-pokemon/</guid>
      <description>&lt;p&gt;Being a tester is like being a pokémon trainer: we want to choose the right pokémon for the job. The problem with doing different types of testing is that we also end up with multiple scripts in different languages and testing tools. We end up choosing a squad of pokémon: one for unit testing, one for automation testing, one for load testing, and so on. Making sure they all work together is a task in itself!&lt;/p&gt;
&lt;p&gt;But what if we could just use one? What if we only needed one Mega-evolved pokémon that could fulfill multiple roles? Is it really possible to write a browser automation script and then reuse it for load testing?&lt;/p&gt;
&lt;p&gt;In this presentation, I talk about my search for the elusive one pokémon that does multiple jobs, the advantages of hybrid load testing, and how to pick pokémon that make our life as trainers and testers easier.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/SFag8ggkXKo&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
  </channel>
</rss>