<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>testing on Nicole van der Hoeven</title>
    <link>https://nicolevanderhoeven.github.io/tags/testing/</link>
    <description>Recent content in testing on Nicole van der Hoeven</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Nicole van der Hoeven</copyright>
    <lastBuildDate>Fri, 28 Jan 2022 23:27:47 +0100</lastBuildDate><atom:link href="https://nicolevanderhoeven.github.io/tags/testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Señor Performo&#39;s Week of Load Testing (k6 Office Hours #39)</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220128-koh39-leandros-week-of-load-testing/</link>
      <pubDate>Fri, 28 Jan 2022 23:27:47 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220128-koh39-leandros-week-of-load-testing/</guid>
      <description>&lt;p&gt;This week for k6 Office Hours, I talked to one of the newest members on our team, &lt;a href=&#34;https://srperf.com&#34;&gt;Leandro Melendez, aka Señor Performo&lt;/a&gt;, about his experience in joining k6/Grafana Labs. We ended up talking about performance &amp;ldquo;deadly sins&amp;rdquo; and how the practice of performance engineering has changed in the last decade.&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/bi-RuT9eZdA&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Why All Roads Lead to Testing</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220125-all-roads-lead-to-testing/</link>
      <pubDate>Tue, 25 Jan 2022 23:59:03 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220125-all-roads-lead-to-testing/</guid>
      <description>&lt;h1 id=&#34;why-all-roads-lead-to-testing&#34;&gt;Why all roads lead to testing&lt;/h1&gt;
&lt;p&gt;Testing is a skill every software engineer should develop.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s easy to dismiss testing as a responsibility only some carry, but it&amp;rsquo;s best thought of as a hat that &lt;em&gt;anyone&lt;/em&gt; can put on. How well you learn to wear this hat affects your career whether or not you&amp;rsquo;re a tester. Here&amp;rsquo;s why.&lt;/p&gt;
&lt;h2 id=&#34;ideas-are-cheap&#34;&gt;Ideas are cheap.&lt;/h2&gt;
&lt;p&gt;In tech, having an idea isn&amp;rsquo;t what sells&amp;ndash; the success is in the execution.&lt;/p&gt;
&lt;p&gt;iPhones didn&amp;rsquo;t become popular because it was the first mobile with a touchscreen. The Nintendo Switch isn&amp;rsquo;t ubiquitous because of its revolutionary hardware. Behind every successful product is a lot of testing.&lt;/p&gt;
&lt;h2 id=&#34;testing-isnt-just-for-testers&#34;&gt;Testing isn&amp;rsquo;t just for testers.&lt;/h2&gt;
&lt;p&gt;Every good software engineer does testing.&lt;/p&gt;
&lt;p&gt;Debugging is a form of testing. Questioning requirements is a form of testing. Testers don&amp;rsquo;t (and shouldn&amp;rsquo;t) have a monopoly on testing. The reality is that everyone is doing it, often without calling it &amp;ldquo;testing&amp;rdquo;.&lt;/p&gt;
&lt;h2 id=&#34;testing-is-about-people-more-than-it-is-about-machines&#34;&gt;Testing is about people more than it is about machines.&lt;/h2&gt;
&lt;p&gt;The fundamental goal of any app is to address a human need.&lt;/p&gt;
&lt;p&gt;Testing is finding new ways to represent and understand this need at all stages of development. Testing is a people problem, not a technical problem.&lt;/p&gt;
&lt;h2 id=&#34;humans-are-irrational&#34;&gt;Humans are irrational.&lt;/h2&gt;
&lt;p&gt;The biggest challenge in building apps is human irrationality.&lt;/p&gt;
&lt;p&gt;We don&amp;rsquo;t always &lt;em&gt;want&lt;/em&gt; what we need, we don&amp;rsquo;t always &lt;em&gt;know&lt;/em&gt; what we need, and even when we&amp;rsquo;re building &lt;em&gt;for&lt;/em&gt; others, we don&amp;rsquo;t always &lt;em&gt;work&lt;/em&gt; towards what we need. Testing is an attempt to make sense of this irrationality.&lt;/p&gt;
&lt;h2 id=&#34;testing-is-an-attitude&#34;&gt;Testing is an attitude.&lt;/h2&gt;
&lt;p&gt;Getting good at testing extends to aspects beyond work.&lt;/p&gt;
&lt;p&gt;Testing is a discipline of questioning. It&amp;rsquo;s having curiosity as a default state and trying to meet people where they are. These are things every project, and every community, needs in spades.&lt;/p&gt;
&lt;h2 id=&#34;testing-is-rarely-the-destination&#34;&gt;Testing is rarely the destination.&lt;/h2&gt;
&lt;p&gt;But some time, some how, all roads lead to testing.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to Actually Remember What You Learn, for Engineers with Long Reading Lists</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220124-how-to-actually-remember-what-you-learn/</link>
      <pubDate>Mon, 24 Jan 2022 21:47:59 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220124-how-to-actually-remember-what-you-learn/</guid>
      <description>&lt;p&gt;Who says you need the terminology of the Zettelkasten process? Here&amp;rsquo;s how I&amp;rsquo;ve learned how to learn and how to apply new ideas to my daily work.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re reading this, you probably make your living on what you&amp;rsquo;ve learned that other people haven&amp;rsquo;t. Unfortunately, if you don&amp;rsquo;t have a written system to keep track of new ideas, you&amp;rsquo;ll probably unlearn everything in a few years.&lt;/p&gt;
&lt;h2 id=&#34;most-people-think-reading--learning&#34;&gt;Most people think reading = learning.&lt;/h2&gt;
&lt;p&gt;Here&amp;rsquo;s why reading isn&amp;rsquo;t enough.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Our brains are best at linking concepts, not at remembering them.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Writing doesn&amp;rsquo;t help us learn; it IS how we learn.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can&amp;rsquo;t learn to swim by reading about it.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If reading isn&amp;rsquo;t enough, then what should you do instead?&lt;/p&gt;
&lt;h3 id=&#34;step-1-consume&#34;&gt;&lt;strong&gt;Step 1: Consume&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;The first step is to consume content, but &lt;em&gt;selectively&lt;/em&gt; so.&lt;/p&gt;
&lt;p&gt;Content could be a book, a video, a podcast, an article, or even a conversation. &lt;em&gt;Take notes&lt;/em&gt; on the author&amp;rsquo;s main points.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt; Shape Up is a methodology emphasising iterative cycles, &amp;ldquo;betting&amp;rdquo; on work to be done, and building fully integrated slices of work.&lt;/p&gt;
&lt;h3 id=&#34;step-2-redefine&#34;&gt;&lt;strong&gt;Step 2: Redefine&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Next, go beyond facts and add your thoughts.&lt;/p&gt;
&lt;p&gt;Think about the broader picture of what the author might be saying, and supplement it with &lt;em&gt;your&lt;/em&gt; opinions. &lt;em&gt;Example:&lt;/em&gt; Shape Up is an Agile methodology concerned with the limits we should apply to different stages of work.&lt;/p&gt;
&lt;h3 id=&#34;step-3-contextualize&#34;&gt;&lt;strong&gt;Step 3: Contextualize&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Think about what the content means to you, specifically&amp;ndash; how does it stack with other things you&amp;rsquo;ve learned? Where does it fit into your interests? Accept that your context, and your notes, will change.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt; Shape Up&amp;rsquo;s idea of fully integrated work supports the notion of context-switching (see: Continuous integration, Multithreading) but could be in contention with productivity concepts like deep work (David Allen), batching, and Productivity Momentum.&lt;/p&gt;
&lt;h2 id=&#34;its-your-brain&#34;&gt;It&amp;rsquo;s your brain!&lt;/h2&gt;
&lt;p&gt;In the end, nobody can tell you the &amp;ldquo;right&amp;rdquo; way to learn.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to Do What Kind of Testing When: Testing Types by Scope</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220122-how-to-do-what-kind-of-testing-when/</link>
      <pubDate>Sat, 22 Jan 2022 16:42:49 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220122-how-to-do-what-kind-of-testing-when/</guid>
      <description>&lt;p&gt;Correctly identifying &lt;em&gt;when&lt;/em&gt; you test could be just as important as &lt;em&gt;what&lt;/em&gt;. Below are types of testing according to scope.&lt;/p&gt;
&lt;h3 id=&#34;static-testing&#34;&gt;Static testing&lt;/h3&gt;
&lt;p&gt;Static testing occurs when requirements are written. Question requirements and spell out what each one means.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Concerns:&lt;/em&gt; Setting up a system to track and link requirements to test cases, negotiating business needs with technical feasibility, clarifying scope.&lt;/p&gt;
&lt;h3 id=&#34;unit-testing&#34;&gt;Unit testing&lt;/h3&gt;
&lt;p&gt;Unit testing occurs when coding begins. Practice Test-Driven Development by translating requirements into tests before writing the code.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Concerns:&lt;/em&gt; Treating test code like application code, getting developer buy-in, communicating technical implementation, performance, pair programming.&lt;/p&gt;
&lt;h3 id=&#34;system-testing&#34;&gt;System testing&lt;/h3&gt;
&lt;p&gt;System testing occurs when a build is released. Employ black-box testing: step back from the code and assess the feature as a whole for consistency.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Concerns:&lt;/em&gt; Adherence to common design standards, equivalence partitioning, boundary value analysis, fighting scope creep, usability, creating test data.&lt;/p&gt;
&lt;h3 id=&#34;system-integration-testing-sit&#34;&gt;System integration testing (SIT)&lt;/h3&gt;
&lt;p&gt;SIT occurs when integrating multiple components. Use white-box or grey-box testing to target the interactions and traffic between components.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Concerns:&lt;/em&gt; API testing, stubbing and mocking, identifying request paths throughout the system, performance benchmarking, observability and analysis.&lt;/p&gt;
&lt;h3 id=&#34;business-acceptance-testing-bat&#34;&gt;Business acceptance testing (BAT)&lt;/h3&gt;
&lt;p&gt;BAT occurs when the code is assessed against overall business goals. Seek out SMEs who can help you verify expected outcomes.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Concerns:&lt;/em&gt; Adherence to business requirements and regulations, process testing, simplifying request flows, identifying potential customer pain points.&lt;/p&gt;
&lt;h3 id=&#34;user-acceptance-testing-uat&#34;&gt;User acceptance testing (UAT)&lt;/h3&gt;
&lt;p&gt;User acceptance testing occurs before code is released to production. Map test cases to requirements and test real-world scenarios.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Concerns:&lt;/em&gt; Testing for superuser workflows, data cleansing, verifying real user behavior from historical logs, exploratory testing, end-to-end performance.&lt;/p&gt;
&lt;h3 id=&#34;regression-testing&#34;&gt;Regression Testing&lt;/h3&gt;
&lt;p&gt;Regression testing occurs between builds. Supplement a robust automation test suite with nuanced manual test cases that address known problem areas.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Concerns:&lt;/em&gt; Setting up a CI/CD pipeline, deciding what to automate, consolidating test and development tools, tracking failures over time.&lt;/p&gt;
&lt;h3 id=&#34;question-everything&#34;&gt;Question everything&lt;/h3&gt;
&lt;p&gt;Remember: &lt;strong&gt;testing is an attitude.&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An Overview of Software Testing</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220119-an-overview-of-software-testing/</link>
      <pubDate>Wed, 19 Jan 2022 17:10:11 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220119-an-overview-of-software-testing/</guid>
      <description>
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/huiptd8Y2I0&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&#34;transcript&#34;&gt;Transcript&lt;/h2&gt;
&lt;p&gt;NICOLE: What is the difference between good software and bad software? Is it features or user interface or marketing? In my totally biased opinion, what actually makes a difference is how well the software was tested. But software testing encompasses a lot of different areas and it doesn&amp;rsquo;t even always have to be someone with a word tester in their job title that does the testing. So whether you&amp;rsquo;re looking to get started in the industry, or just trying to cross skill, here&amp;rsquo;s an overview of the main types of software testing.&lt;/p&gt;
&lt;p&gt;Is it just me, or does your desk get that clutter too after a week of work?&lt;/p&gt;
&lt;p&gt;Anyway, software testing is the process of validating whether an application works as intended, but there&amp;rsquo;s a lot of vagueness in that statement. One of the broadest ways to categorize testing types though, is whether it&amp;rsquo;s functional or operational.&lt;/p&gt;
&lt;p&gt;Functional testing is more about application features. Is there a form to capture user email addresses? Is there a button next to it that submits those addresses? Once the button is clicked, where do the user details go? Do they go to the database? Are they stored correctly? Those are the sort of ways in which functional testers think. Operational testing traditionally called non-functional testing, is a way of verifying software quality and aspects that extend beyond the features of the application.&lt;/p&gt;
&lt;p&gt;Operational testing sometimes involves concerns that are more subjective or qualitative. So it can be a little bit more difficult to test, because those things only arise in certain conditions. I&amp;rsquo;m saying operational testing here, instead of non-functional testing, because I was talking to Paul Bruce who made an excellent video just on this topic. He talks about why the term nonfunctional requirement is really a bit of a misnomer.&lt;/p&gt;
&lt;p&gt;PAUL: It relegates all these other things, security, performance, installation, deployment, accessibility. It relegates them to a nice to have, so it should be functional versus operational.&lt;/p&gt;
&lt;p&gt;NICOLE: So I&amp;rsquo;m using his term operational testing instead.&lt;/p&gt;
&lt;p&gt;Here are the different forms of operational or non-functional testing.&lt;/p&gt;
&lt;p&gt;First there&amp;rsquo;s accessibility testing. It is involved with verifying that end users can consume or navigate content. Usually through assistive devices like screen readers. While most forms of testing begin with a statistically normal user in mind, accessibility testing seeks out outliers in terms of location, linguistic background and disability.&lt;/p&gt;
&lt;p&gt;Usability testing is designing with user experience in mind, specifically concerning the placement of on-screen elements and the intuitiveness of the process flow of an application.&lt;/p&gt;
&lt;p&gt;Localization testing is a way of making sure that applications are usable in the local context, in the sense of being colloquially appropriate for users in different countries and from different cultures.&lt;/p&gt;
&lt;p&gt;Security testing verifies that a system has no flaws that could be exploited, to gain access to confidential information or features that would not otherwise be accessed by expected means.&lt;/p&gt;
&lt;p&gt;So that was me talking from my home in the Netherlands, but this week I am in Portugal. The remote working life, am I right?&lt;/p&gt;
&lt;p&gt;But anyway, performance testing is my favorite topic and my favorite type of testing because that&amp;rsquo;s the one that I&amp;rsquo;ve had the most experience with. Performance testing is more qualitative. So it&amp;rsquo;s more about how well the application works. And there are two main types of performance testing and that&amp;rsquo;s front-end performance, and back-end performance testing.&lt;/p&gt;
&lt;p&gt;Front-end performance testing seeks to verify the user experience at the interface level. So that&amp;rsquo;s everything that the end user sees on their local machine.&lt;/p&gt;
&lt;p&gt;There are different approaches to front-end performance testing, and the first of them is performance profiling. Performance profiling involves running your application through a series of automated checks. And there are a lot of sites for this, where you just put in your URL, if it&amp;rsquo;s a web app, and you get a score in the end. That tells you how performance your application is, the most popular example for this and also the easiest to get started with, is DevTools because that&amp;rsquo;s already in Chrome and Firefox based browsers. But you can also go to sites like Webpagetest, or GTMetrix, YSlow, which is a plugin, or you can use Google Lighthouse, which is now included with Chrome Dev Tools.&lt;/p&gt;
&lt;p&gt;The next approach to front-end performance testing is called RUM or Real User Monitoring. So the difference is that with performance profiling, that&amp;rsquo;s often done manually, and as a one-off thing, like maybe at the beginning of a test or during, but Real User Monitoring is not usually done within testing environments. As the name suggests, these tools measure the experience of real users. So they have to be run in production. Examples of tools in this space are; New Relic&amp;rsquo;s RUM, Elastic has a RUM as well, there&amp;rsquo;s Catchpoint, SpeedCurve Uptrends and many more.&lt;/p&gt;
&lt;p&gt;And the third approach to measuring front-end performance is by using some sort of browser-based automation tool. So typically this has been something like Selenium, but that&amp;rsquo;s falling out of favor in terms of more modern solutions like Playwright, Puppeteer, Cypress and so on.&lt;/p&gt;
&lt;p&gt;So front-end performance is about everything that the user sees on their end, but back-end performance testing is about everything that they don&amp;rsquo;t see. It&amp;rsquo;s about the network. It&amp;rsquo;s about latency, the application servers, the way the infrastructure is set up and all of those things that are a little bit more difficult to look into, but can also have severe bottlenecks. Back-end performance testing seeks to verify aspects of an application such as scalability, elasticity, availability, reliability and responsiveness.&lt;/p&gt;
&lt;p&gt;Scalability is the application&amp;rsquo;s ability to respond to changes in demand. This could mean scaling up, which means increasing the resources available to a server, but it could also mean scaling out, meaning increasing the number of servers that are available to handle the application load.&lt;/p&gt;
&lt;p&gt;Elasticity is a related topic to scalability, except where scalability is all about scaling up or out. Elasticity also emphasize a scaling down or in, and that&amp;rsquo;s because having these services or servers available on the Cloud that are dynamically adjusting can also be quite expensive. So elasticity makes sure that the infrastructure that&amp;rsquo;s available or the resources available are always appropriate for the size of the demand. So when demand increases, elasticity also checks whether the application decreases it servers or resources in response to that.&lt;/p&gt;
&lt;p&gt;Availability is how long the application stays up, despite changing circumstances in production. So this is typically measured by uptime. Availability can also be tested using disaster recovery procedures, and you&amp;rsquo;re not just testing the application itself, but also the processes around it. So are there enough people that are on call so that they would be able to come in and troubleshoot when there&amp;rsquo;s a production incident? All of those things are included in application availability.&lt;/p&gt;
&lt;p&gt;Reliability checks to see how your application behaves in response to unexpected errors. Reliability basically takes it as a given that your application is going to fail somehow, sometime, maybe you don&amp;rsquo;t know exactly when that will be or how it will fail, but it&amp;rsquo;s going to happen. So a big part of reliability and site reliability engineering is trying to expose your application to those failures beforehand so that you can build confidence about how it will behave when those things actually happen in production.&lt;/p&gt;
&lt;p&gt;And the last aspect to back-end performance testing is responsiveness. And this is usually equated with load testing. Load testing is more of a technique for testing though. And really load tests can be used to test not just responsiveness, but also reliability or availability or scalability, basically any of the &amp;ldquo;ilities&amp;rdquo; in this part of back-end performance testing.&lt;/p&gt;
&lt;p&gt;Protocol-based load testing verifies the backend performance of an application, not by simulating real users accessing the application, but by simulating the underlying requests that go back and forth between the client or the user and the application servers. One of the benefits of protocol-based load testing is that it takes up fewer resources on the side of the load generator, and therefore is less expensive to run. Some popular protocol-based load testing tools are k6, JMeter, Gatling LoadRunner, NeoLoad, and Silk Performer.&lt;/p&gt;
&lt;p&gt;Browser-based load testing verifies the application by simulating real users accessing it. So it also has the benefit of including these front-end performance metrics. Browser-based testing can also be called browser-driven or UI-based testing. Some popular tools for browser-based load testing are Playwright, Puppeteer, Flood Element and as of a few weeks ago, k6.&lt;/p&gt;
&lt;p&gt;Then there&amp;rsquo;s hybrid load testing, which takes the best of protocol and browser-based load testing tools by combining them in one test. Now this can present some challenges, especially if you&amp;rsquo;re using different tools for the browser-based script, than you&amp;rsquo;re using for the protocol-based script. The ideal is to use your protocol based load testing tool, to simulate majority of the load to cut down on costs for the execution and scaling out of your load test. And then you run a handful of users using your browser based load testing tool. So you still get some metrics for front-end performance while that load is being applied by the protocol based tool.&lt;/p&gt;
&lt;p&gt;Testing software can be really daunting because there are many aspects of an application that you can test. But that&amp;rsquo;s because there&amp;rsquo;s also many aspects of an application that can fail. And that&amp;rsquo;s why all roads lead to testing and why the success of an app hinges on how well it&amp;rsquo;s been tested.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;d like to zero in, on load testing in particular, check out this video that I made on what load testing is. Thanks for watching. And like they say, here in Portugal, Obrigada!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Six Performance Testing Hats</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220114-six-performance-testing-hats/</link>
      <pubDate>Fri, 14 Jan 2022 16:30:34 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220114-six-performance-testing-hats/</guid>
      <description>&lt;p&gt;I was reading &lt;a href=&#34;https://amzn.to/3tvLYM9&#34;&gt;Six Thinking Hats&lt;/a&gt; by Edward de Bono when I realized that the premise could be applied to performance testing:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://nicolevanderhoeven.github.io/assets/six-performance-testing-hats.png&#34; alt=&#34;The Six Performance Testing Hats&#34;&gt;&lt;/p&gt;
&lt;p&gt;Each hat represents a different way of thinking, which can be useful when working through issues. Sometimes, wearing only one hat can cause us to fixate on incorrect assumptions, and &amp;ldquo;putting on another hat&amp;rdquo; can help shake things up and get to actually fixing what went wrong.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What Tabletop Games Teach Us About Application Perfomance</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220112-what-tabletop-games-teach-us-about-application-perfomance/</link>
      <pubDate>Wed, 12 Jan 2022 16:30:29 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220112-what-tabletop-games-teach-us-about-application-perfomance/</guid>
      <description>&lt;p&gt;Tabletop games and application performance have more in common than you might think.&lt;/p&gt;
&lt;p&gt;See, it&amp;rsquo;s all about optimization. Both involve juggling several variables: some that you can control, and some that you can&amp;rsquo;t.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s what I&amp;rsquo;ve learned about application performance from playing tabletop games.&lt;/p&gt;
&lt;h2 id=&#34;1-get-more-workers&#34;&gt;#1: Get more workers&lt;/h2&gt;
&lt;p&gt;In worker placement games, you should always spend your first worker to train more workers.&lt;/p&gt;
&lt;p&gt;Similarly, one of the most basic ways to increase concurrency is multithreading: using more than one thread at a time. (See: Golang) This applies to testing tools as much as to systems. The 1 Thread: 1 Virtual User paradigm is flawed.&lt;/p&gt;
&lt;h2 id=&#34;2-spend-time-on-getting-your-engine-going&#34;&gt;#2: Spend time on getting your engine going&lt;/h2&gt;
&lt;p&gt;Get your big combos in place before you tap to attack.&lt;/p&gt;
&lt;p&gt;Things like setting up automation frameworks or CI/CD pipelines DO set you back in the beginning, but they are worth their mana cost in the long run.&lt;/p&gt;
&lt;h2 id=&#34;3draft-with-others-in-mind&#34;&gt;#3: Draft with others in mind&lt;/h2&gt;
&lt;p&gt;The trick to drafting is knowing what you&amp;rsquo;re leaving for others as much as what you&amp;rsquo;re taking for yourself.&lt;/p&gt;
&lt;p&gt;The short game is getting your team to do the testing. The long game is getting everyone in the company involved in testing.&lt;/p&gt;
&lt;h2 id=&#34;4-hope-for-a-nat-20-plan-for-a-nat-1&#34;&gt;#4: Hope for a nat 20, plan for a nat 1&lt;/h2&gt;
&lt;p&gt;Sometimes proficiency, expertise, and a luckstone just aren&amp;rsquo;t enough.&lt;/p&gt;
&lt;p&gt;Instead of wondering &lt;em&gt;whether&lt;/em&gt; an app will fail, take for granted that it will, and start planning for it. Keep that Action Surge in your back pocket.&lt;/p&gt;
&lt;h2 id=&#34;5-sometimes-you-just-have-to-trade-for-sheep&#34;&gt;#5: Sometimes, you just have to trade for sheep&lt;/h2&gt;
&lt;p&gt;The 2:1 port is valuable, but not always the best option.&lt;/p&gt;
&lt;p&gt;Learn what you can, but accept that you can&amp;rsquo;t learn it all. Reach out to others with compatible skillsets and ask the &amp;ldquo;stupid&amp;rdquo; questions that nobody else wants to ask.&lt;/p&gt;
&lt;h2 id=&#34;testing-is-a-team-sport-and-everyone-gets-a-chance-to-play&#34;&gt;Testing is a team sport, and everyone gets a chance to play.&lt;/h2&gt;
&lt;p&gt;Happy gaming!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Tester&#39;s Toolbox Is Flawed</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220111-the-testers-toolbox-is-flawed/</link>
      <pubDate>Tue, 11 Jan 2022 16:30:49 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220111-the-testers-toolbox-is-flawed/</guid>
      <description>&lt;p&gt;Every tester has a toolbox.&lt;/p&gt;
&lt;p&gt;In the toolbox rests a variety of tools for every conceivable purpose. Part of our job, as testers, is to choose the right one for the job. Sounds reasonable, right?&lt;/p&gt;
&lt;p&gt;That kind of thinking could be dangerous.&lt;/p&gt;
&lt;h2 id=&#34;the-right-tool-for-every-job-fails-for-multiple-jobs&#34;&gt;&amp;ldquo;The right tool for every job&amp;rdquo; fails for multiple jobs.&lt;/h2&gt;
&lt;p&gt;You end up with multiple tools. One for accessibility testing. Another for API testing. Another for browser testing. Another for load testing. &lt;em&gt;This is the modern tester&amp;rsquo;s dilemma&lt;/em&gt;: we spend more time working with our tools than with the application under test.&lt;/p&gt;
&lt;p&gt;In the real world, including a new tool in your testing stack means a new framework, usually a new programming language, and sometimes even new colleagues with experience in those tools. And what about continuous testing? All those tools have to talk to each other at some point.&lt;/p&gt;
&lt;p&gt;More tools = more time, effort, and money.&lt;/p&gt;
&lt;h3 id=&#34;when-choosing-tools-prioritize-multitools&#34;&gt;&lt;strong&gt;When choosing tools, prioritize multitools.&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;A multitool can be used for different purposes and prioritizes flexibility.&lt;/p&gt;
&lt;p&gt;Here are a few ways to spot a multitool:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#1: It is a polymath.&lt;/strong&gt; A multitool is good at many things and is limited in use case only by the imagination of those that use it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#2: It uses what you know.&lt;/strong&gt; A multitool is built on languages and frameworks you and your team already know, reducing ramp-up time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#3 It plays well with others.&lt;/strong&gt; A multitool doesn&amp;rsquo;t force you to use it to the exclusion of everything else. It integrates well with best-in-class tools.&lt;/p&gt;
&lt;p&gt;When you optimize for individual jobs, you&amp;rsquo;re missing the big picture. You&amp;rsquo;re ultimately left holding the ends of multiple tools and creating a kraken of a test suite with all these tools cobbled together.&lt;/p&gt;
&lt;p&gt;Instead, prioritize multitools.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Obsidian for the Uninitiated</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220110-obsidian-for-the-uninitiated/</link>
      <pubDate>Mon, 10 Jan 2022 23:07:06 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220110-obsidian-for-the-uninitiated/</guid>
      <description>&lt;h1 id=&#34;obsidian-for-the-uninitiated&#34;&gt;Obsidian for the Uninitiated&lt;/h1&gt;
&lt;p&gt;You&amp;rsquo;ve installed Obsidian and created a new vault. Now what?&lt;/p&gt;
&lt;p&gt;Unfortunately, it can be more than a little daunting to get started with. It doesn&amp;rsquo;t help that there are terms like &lt;em&gt;Zettelkasten&lt;/em&gt; and &lt;em&gt;Maps of Content&lt;/em&gt; and &lt;em&gt;fleeting notes&lt;/em&gt; and &lt;em&gt;digital garden&lt;/em&gt; that are all just trying to structure what we all learned to do in primary school.&lt;/p&gt;
&lt;h2 id=&#34;start-by-logging-what-youre-doing&#34;&gt;Start by logging what you&amp;rsquo;re doing.&lt;/h2&gt;
&lt;p&gt;Having a rigid structure does wonders for curtailing creativity and plain fun. Instead, I recommend starting small.&lt;/p&gt;
&lt;p&gt;Here are some small steps to take after installing Obsidian:&lt;/p&gt;
&lt;h3 id=&#34;step-1-enable-the-daily-notes-plugin&#34;&gt;&lt;strong&gt;Step 1: Enable the Daily Notes plugin&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;The most game-changing feature of Obsidian is plugins.&lt;/p&gt;
&lt;p&gt;Go into Settings &amp;gt; Core Plugins, and enable the &lt;em&gt;Daily notes&lt;/em&gt; plugin.&lt;/p&gt;
&lt;p&gt;Then, exit out of the dialog boxes and hit CMD P (Mac) or CTRL P (Windows) to bring up the command pane. Search for and select &lt;em&gt;Daily notes: Open today&amp;rsquo;s daily note&lt;/em&gt;. That creates a new note in your vault with today&amp;rsquo;s date.&lt;/p&gt;
&lt;p&gt;From now on, do this every day and log things you do during the day: things to do, appointments to keep, videos you watched.&lt;/p&gt;
&lt;h3 id=&#34;step-2-the-next-time-you-consume-content-take-notes&#34;&gt;&lt;strong&gt;Step 2: The next time you consume content, take notes.&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Now, the next time you read or watch something interesting, type its title into Obsidian with brackets:&lt;code&gt;[[Cool video I watched]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s now a link. CMD+click on that link, or click the glasses icon on the top right to switch to Preview mode, and then click on the link. You should now have a new note. Write about what you thought of the video.&lt;/p&gt;
&lt;h3 id=&#34;step-3-start-identifying-and-fleshing-out-ideas&#34;&gt;&lt;strong&gt;Step 3: Start identifying and fleshing out ideas.&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Keep going with these steps and every now and then, start to identify cool ideas you come across. Create new notes from them just like you did in Step 2. Don&amp;rsquo;t worry about getting it all; just do it when and until you feel like it.&lt;/p&gt;
&lt;p&gt;These three simple steps, over time, will be the foundations of your own Personal Knowlege Management system with Obsidian.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5 Ways to Use Obsidian as a Software Engineer</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220109-5-ways-to-use-obsidian-as-a-software-engineer/</link>
      <pubDate>Sun, 09 Jan 2022 19:20:49 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220109-5-ways-to-use-obsidian-as-a-software-engineer/</guid>
      <description>&lt;p&gt;Yesterday, I wrote about why I think taking notes is the surprising foundation of a tester&amp;rsquo;s career.&lt;/p&gt;
&lt;p&gt;But it&amp;rsquo;s not just testers. Every software engineer is a knowledge worker, and that means we get paid for what we know. Using a Personal Knowledge Management (PKM) system such as &lt;a href=&#34;http://Obsidian.md&#34;&gt;Obsidian.md&lt;/a&gt; helps us keep up with the constant barrage of new ideas in tech.&lt;/p&gt;
&lt;p&gt;Here are 5 things I use Obsidian for.&lt;/p&gt;
&lt;h2 id=&#34;1-my-very-own-stack-overflow&#34;&gt;#1: My very own Stack Overflow&lt;/h2&gt;
&lt;p&gt;If you code, you&amp;rsquo;ve used Stack Overflow.&lt;/p&gt;
&lt;p&gt;What if you had your &lt;strong&gt;own&lt;/strong&gt; Stack Overflow, one that contained cheat sheets of every language you&amp;rsquo;ve ever tried to hack something up in, including only commands relevant to your job? This is exactly &lt;a href=&#34;https://notes.nicolevanderhoeven.com/Python&#34;&gt;what I&amp;rsquo;ve done for Python&lt;/a&gt; recently, and it&amp;rsquo;s helping me solidify my knowledge.&lt;/p&gt;
&lt;h2 id=&#34;2-tools-database&#34;&gt;#2: Tools database&lt;/h2&gt;
&lt;p&gt;There&amp;rsquo;s a tool for everything.&lt;/p&gt;
&lt;p&gt;To keep them straight, I have a page for every load testing tool I try, with tutorials for how to get started, an assessment of its features, and observations I had while attempting to learn it. &lt;a href=&#34;https://notes.nicolevanderhoeven.com/k6+(tool)&#34;&gt;Here&amp;rsquo;s what I have for the load testing tool k6&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Bonus: I also use &lt;a href=&#34;https://github.com/blacksmithgu/obsidian-dataview&#34;&gt;the Dataview plugin&lt;/a&gt; to query tools that fit my criteria.&lt;/p&gt;
&lt;h2 id=&#34;3-an-agile-workspace&#34;&gt;#3: An Agile workspace&lt;/h2&gt;
&lt;p&gt;If Agile is good enough for my professional work, it&amp;rsquo;s good enough for my personal work.&lt;/p&gt;
&lt;p&gt;I use the &lt;a href=&#34;https://github.com/mgmeyers/obsidian-kanban&#34;&gt;Kanban plugin&lt;/a&gt; to keep track of projects, create weekly and monthly review/retro templates, and work iteratively using &lt;a href=&#34;https://github.com/bjsi/incremental-writing&#34;&gt;the Incremental Writing plugin&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;4-a-public-learning-log&#34;&gt;#4: A public learning log&lt;/h2&gt;
&lt;p&gt;Learning in public is the fastest way to improve.&lt;/p&gt;
&lt;p&gt;When I&amp;rsquo;m trying to figure something out, I document my attempts. With Obsidian Publish, I can quickly push this log out to my domain and share them with colleagues to get a quick review so that they can easily follow my train of thought and tell me where I went wrong.&lt;/p&gt;
&lt;h2 id=&#34;5-a-digital-garden-of-software-ideas&#34;&gt;#5: A digital garden of software ideas&lt;/h2&gt;
&lt;p&gt;Build libraries, not feeds.&lt;/p&gt;
&lt;p&gt;I use Obsidian to save things I read/watch/listen to but also to save space for ideas I&amp;rsquo;ve learned to germinate. I publish notes before they&amp;rsquo;re fully fleshed out, with the goal of growing everything over time.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://notes.nicolevanderhoeven.com&#34;&gt;Today, I have 4,567 notes&lt;/a&gt;, all about things that matter to me.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Every engineer should have a PKM system.&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Take Notes, Not Tools</title>
      <link>https://nicolevanderhoeven.github.io/blog/20220108-take-notes-not-tools/</link>
      <pubDate>Sat, 08 Jan 2022 17:00:44 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20220108-take-notes-not-tools/</guid>
      <description>&lt;p&gt;When I first got into testing, I thought that testing was about learning different tools and frameworks.&lt;/p&gt;
&lt;p&gt;I learned how to use Neoload, then LoadRunner, then JMeter, and then SeleniumSilkPerformerVisualStudioGatlingPuppeteerPlaywrightk6 in short succession. I took courses on JavaScript, on C, on Java. I ticked off tools like a grocery list.&lt;/p&gt;
&lt;p&gt;It didn&amp;rsquo;t take me long to realize that I still wasn&amp;rsquo;t a good tester.&lt;/p&gt;
&lt;h2 id=&#34;taking-notes-not-tools-is-what-makes-a-good-tester&#34;&gt;Taking notes, not tools, is what makes a good tester.&lt;/h2&gt;
&lt;p&gt;When you think about it, a lot of things a tester does revolves around taking good notes.&lt;/p&gt;
&lt;p&gt;Requirements are just notes on what the business wants to achieve. Test scenarios are notes on situations that the team wants to simulate. Test cases are notes on how a user would use an application. Defects are notes on issues.&lt;/p&gt;
&lt;p&gt;The quality of a tester&amp;rsquo;s notes dictates the quality of their work.&lt;/p&gt;
&lt;h3 id=&#34;listen-to-people-not-tool-tutorials&#34;&gt;&lt;strong&gt;Listen to people, not tool tutorials&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Take notes on what users do.&lt;/strong&gt; Talk to the business. Pore through Google Analytics logs. Piece together a story of the kind of people who use your application, and how they use it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Take notes on problem areas.&lt;/strong&gt; Talk to customer support about the most common questions they get&amp;ndash; they know more about pain points than anyone else in the company. Talk to the ops engineers who were on call during the last production incident. These problems are what you&amp;rsquo;ll need to test later.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Take notes on what you&amp;rsquo;ve learned.&lt;/strong&gt; If you don&amp;rsquo;t like learning, you&amp;rsquo;re in the wrong field. Document everything, even things you think you&amp;rsquo;ll never forget, because one day, you WILL forget.&lt;/p&gt;
&lt;p&gt;Taking notes, not tools, is the foundation every testing career is built on.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Performance Objective: Intro to Load Testing With k6 and Grafana</title>
      <link>https://nicolevanderhoeven.github.io/blog/20211123-intro-to-load-testing-with-k6-and-grafana/</link>
      <pubDate>Tue, 23 Nov 2021 17:05:06 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20211123-intro-to-load-testing-with-k6-and-grafana/</guid>
      <description>
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/fjq-JmrLjPc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;I spoke at the Performance Objective meetup to talk about how to use k6 and Grafana for beginners. I always enjoy talking to like-minded engineers, and I think sharing ideas in a meetup context is probably the best way to do it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Everyone Can Contribute: Load Performance Testing With k6</title>
      <link>https://nicolevanderhoeven.github.io/blog/20211123-load-performance-testing-with-k6/</link>
      <pubDate>Tue, 23 Nov 2021 16:57:26 +0100</pubDate>
      
      <guid>https://nicolevanderhoeven.github.io/blog/20211123-load-performance-testing-with-k6/</guid>
      <description>
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/_ty40gSaaw8&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;This is a recording of a live meetup I spoke at, the Everybody Can Contribute Café hosted by Michael Friedrich, Senior Developer Evangelist at GitLab. This was a more casual conversation and show-and-tell about k6&amp;rsquo;s capabilities, and I really enjoyed it!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>